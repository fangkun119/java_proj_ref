[TOC]

# 分布式事务解决方案

## 1. 2PC：两阶段提交

### (1) 事务执行过程

> 角色：事务协调器，事务参与方
>
> 阶段一：协调器请求参与方在本地事务中进行预执行（precommit），记录undo和redo日志并汇报结果
>
> 阶段二：事务协调器确认预执行情况，要求所有参与方提交或回滚本地事务

### (2) 优缺点

> 优点：尽量保证了数据一致性，实现成本低（可以直接借助数据库的分布式事务）
>
> 缺点：
>
> * 单点故障：事务管理器是单点
> * 同步阻塞：阶段1执行之后，资源管理器中的资源（例如DB行）处于阻塞状态，直至阶段2的提交或回滚完成才能释放资源，无法用于高并发场景
> * 数据不一致的可能性仍然存在：例如阶段2的commit请求没有发送到所有的参与者，部分参与者处于阻塞状态，同时数据也处于不一致状态

### (3) 实现参考

> 各大主流数据库都有自己的实现，MySQL从5.5开始支持2PC

## 2. 3PC：三阶段提交

> 角色：事务协调器，事务参与方
>
> 阶段一：协调器询问参与方是否可以提交，需得到全部的ACK确认
>
> 阶段二：协调器请求参与方进行预执行（precommit）
>
> * 参与方在各自的本地事务中执行操作，并记录undo和redo日志
> * 参与方向协调器汇报执行结果：成功或失败
>
> 阶段三：协调器确认事务
>
> * 如果有参与方预执行失败：协调器告诉参与方放弃事务不要提交
> * 如果参与方全部预执行成功：
>     * 协调器通知所有参与方COMMIT本地事务
>     * 如果有一个参与方提交失败，协调器要求所有参与方回滚

## 3. TCC：Try-Confirm-Cancel

### (1) 背景

> 解决了2PC、3PC的几个缺点：
>
> * 解决了协调者端点的问题，改由业务发起方来完成这个部分任务，而业务活动管理器也变成多点
> * 解决同步阻塞问题：引入超时机制，并且不会锁定整个资源，将资源转换为业务逻辑的形式，锁粒度变小
> * 数据一致性：由业务活动管理器控制
>
> 原始论文："Life beyond Distributed Transactions:an Apostate’s Opinion", by Pat Helland, 2007

### (2) 事务执行过程

角色

> * 主业务服务：发起并完成整个业务活动
> * 从业务服务：提供TCC业务操作
> * 业务活动管理器：控制业务活动的一致性
>     * 分布式事务执行时，登记事务内的各个TCC业务操作
>     * 分布式事务提交时，对各个TCC业务操作进行确认（Confirm）
>     * 分布式事务取消时，对各个TCC操作进行取消（Cancel）

过程

> <div align="left"><img src="https://raw.githubusercontent.com/kenfang119/pics/main/sysdesign/sysdesign_tcc_steps.jpg" width="400" /></div>
>
> Try阶段：尝试执行，完成业务检查（一致性）和业务资源预留（准隔离性），但不会提交
>
> * 例如A向B购买一个100元的商品
> * A的余额需要大于100元，B的商品库存需要大于1
>
> Confirm阶段：真正执行
>
> * 只使用Try阶段预留的业务资源
> * 操作需要满足幂等性，因为失败后有可能会进行重试
>
> Cancel阶段：取消执行
>
> * 释放Try阶段预留的业务资源
> * 操作需要满足幂等性

### (3) 使用范围

> 要求强隔离性、严格要求一致性的场景；执行时间较短的业务

### (4) 参考实现：ByteTCC

> [https://github.com/liuyangming/ByteTCC/](https://github.com/liuyangming/ByteTCC/)

## 4. 应用消息队列 + 消息表：实现最终一致性（BASE）

### (1) 本地消息表

方法

> 将需要分布式处理的任务，通过消息日志的方式来异步执行
>
> 1. 消息日志：存储在本地文本、数据库、或者消息队列中
>
> 2. 通过业务规则自动或基于事件触发来发起重试
>
> <div align="left"><img src="https://raw.githubusercontent.com/kenfang119/pics/main/sysdesign/sysdesign_distribute_trx_local_msg_table.jpg" width="500" /></div>
>
> 原始论文：["Base: An Acid Alternative"](https://queue.acm.org/detail.cfm?id=1394128)

例子：购买商品

> 1. 将扣款和扣减库存操作写入同一个事务
> 2. 定时任务轮询本地事务表，向商品服务器发送消息
> 3. 商品服务器扣减库存，更新事务表中对应消息的状态
> 4. 商品服务器直接（或通过定时任务）通知扣款服务器
> 5. 扣款服务器进行扣款，并更新事务表中的事务状态
> 6. 备注：(1) 消息可能重复发送、需要进行重复检查 (2) 有重试的可能，执行的操作需要保证幂等性

### (2) 参考实现：RocketMQ

事务执行过程如下

> <div align="left"><img src="https://raw.githubusercontent.com/kenfang119/pics/main/sysdesign/sysdesign_roketmq_trx.jpg" width="600" /></div>

正常情况：

> * 阶段一：生产者发送Prepared Message到消息队列，并得到一个功能类似句柄的`消息地址`
>
> * 阶段二：生产者执行本地事务
>
> * 阶段三：生产者通过`消息地址`来修改消息的状态，使接受者能够收到这个消息

异常情况：

> * 生产者本地事务失败：阶段三不会发生，因此消费者无法接收到消息
> * 消费者接收消息超时：消息集群会自动进行重试，因此Consumer在处理消息时需要保证幂等性

## 5. Sega事务

### (1) 原理

> 将长事务拆分为多个本地短事务，由Sega事务协调器处理。
>
> 每个短事务都有两种操作：T（事务操作），C（补偿操作：失败回滚时使用）
>
> * 正常情况：按正向顺序执行事务操作 T<sub>1</sub>，T<sub>2</sub>，……，T<sub>n</sub>
> * 异常情况：按反向顺序执行补偿操作进行回滚：T<sub>1</sub>，T<sub>2</sub>，……，T<sub>j</sub>，C<sub>j</sub>，C<sub>2</sub>，……，C<sub>1</sub>
>
> 原版的Sega模式中，没有进行事务隔离，因此会被其他事务影响。解决如下：
>
> * 华为对Sega的实现中，在业务层加入了Session以及锁机制，来保证串行化操作资源
> * 也可以在业务逻辑的设计层面，引入类似资金冻结这样的步骤，来隔离这部分接下来要用的资源

### (2) 参考实现：servicecomb

> 华为的servicecomb

## 6. Seata

> 

## 附录：CAP和BASE

### (1) CAP

> `P（分区容错性）`：当出现网络分区后（例如某个节点的网络出现故障），整个分布式系统仍然能够继续工作
>
> `A（可用性）`：非故障节点在合理时间内返回合理的响应
>
> * 合理时间：请求不会被无限阻塞，在合理时间内返回
> * 合理响应：返回正确的计算结果
>
> `C（一致性）`：读操作能返回最新的写操作
>
> * 强一致性：某个节点更新了数据，其他节点都能读取到这个最新的数据

### (2) BASE

> `BA：Basically Available，基本可用`：分布式系统出现故障时、容许损失部分功能的可用性，但核心功能仍然可用
>
> `S：Soft State，软状态`：容许系统中存在中间状态（短暂的不一致）并且不会影响可用性
>
> `E：Eventually Consistent，最终一致性`：经过一段时间后，所有节点的数据都将达到一致