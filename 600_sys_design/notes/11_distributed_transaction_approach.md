[TOC]

# 分布式事务解决方案

## 1. 基于XA规范的分布式事务：2PC、3PC

> 基于 XA 协议实现的分布式事务，XA 协议中分为两部分：事务管理器和本地资源管理器。
>
> * 本地资源管理器往往由数据库实现（例如 Oracle、MYSQL 5.5+等）都实现了 XA 接口
> * 事务管理器则作为一个全局的调度者。

### (1) 2PC：两阶段提交

#### (a) 事务执行过程

> 角色：事务协调器，事务参与方
>
> 阶段一：协调器请求参与方在本地事务中进行预执行（precommit），记录undo和redo日志并汇报结果
>
> 阶段二：事务协调器确认预执行情况，要求所有参与方提交或回滚本地事务

#### (b) 优缺点

> 优点：尽量保证了数据一致性，实现成本低（可以直接借助数据库的分布式事务）
>
> 缺点：
>
> * 单点故障：事务管理器是单点
> * 同步阻塞：阶段1执行之后，资源管理器中的资源（例如DB行）处于阻塞状态，直至阶段2的提交或回滚完成才能释放资源，无法用于高并发场景
> * 数据不一致的可能性仍然存在：例如阶段2的commit请求没有发送到所有的参与者，部分参与者处于阻塞状态，同时数据也处于不一致状态

### (2) 3PC：三阶段提交

#### (a) 事务执行过程

> 角色：事务协调器，事务参与方
>
> 阶段一：协调器询问参与方是否可以提交，需得到全部的ACK确认
>
> 阶段二：协调器请求参与方进行预执行（precommit）
>
> * 参与方在各自的本地事务中执行操作，并记录undo和redo日志
> * 参与方向协调器汇报执行结果：成功或失败
>
> 阶段三：协调器确认事务
>
> * 如果有参与方预执行失败：协调器告诉参与方放弃事务不要提交
> * 如果参与方全部预执行成功：
>     * 协调器通知所有参与方COMMIT本地事务
>     * 如果有一个参与方提交失败，协调器要求所有参与方回滚

### (3) 优缺点

优点

> 1. 阻塞问题解决：2PC只有协调者有超时机制，而3PC参与者也引入了超时机制，因此当协调者宕机时，参与者就不会一直阻塞
> 2. 增加了一个询问准备阶段，保证在执行事务之前，各个节点的状态时一致的

缺点

> 执行开销仍然比较大

## 2. 基于业务层的方案：TCC（Try-Confirm-Cancel）

### (1) 背景

> 解决了2PC、3PC的几个缺点：
>
> * 解决了协调者端点的问题，改由业务发起方来完成这个部分任务，而业务活动管理器也变成多点
> * 解决同步阻塞问题：引入超时机制，并且不会锁定整个资源，将资源转换为业务逻辑的形式，锁粒度变小
> * 数据一致性：由业务活动管理器控制
>
> 原始论文："Life beyond Distributed Transactions:an Apostate’s Opinion", by Pat Helland, 2007

### (2) 事务执行过程

角色

> * 主业务服务：发起并完成整个业务活动
> * 从业务服务：提供TCC业务操作
> * 业务活动管理器：控制业务活动的一致性
>     * 分布式事务执行时，登记事务内的各个TCC业务操作
>     * 分布式事务提交时，对各个TCC业务操作进行确认（Confirm）
>     * 分布式事务取消时，对各个TCC操作进行取消（Cancel）

过程

> <div align="left"><img src="https://raw.githubusercontent.com/kenfang119/pics/main/sysdesign/sysdesign_tcc_steps.jpg" width="400" /></div>
>
> Try阶段：尝试执行，完成业务检查（一致性）和业务资源预留（准隔离性），但不会提交
>
> * 例如A向B购买一个100元的商品
> * A的余额需要大于100元，B的商品库存需要大于1
>
> Confirm阶段：真正执行
>
> * 只使用Try阶段预留的业务资源
> * 操作需要满足幂等性，因为失败后有可能会进行重试
>
> Cancel阶段：取消执行
>
> * 释放Try阶段预留的业务资源
> * 操作需要满足幂等性

另一个例子：商品购买

> Try阶段：锁定库存
>
> Confirm：库存扣减
>
> Cancel：释放库存

### (3) 适用范围

> 不存在资源阻塞问题，每个方法都直接进行提交或回滚补偿
>
> 适用于要求强隔离性、严格要求一致性的场景，执行时间较短的业务
>
> 实现较复杂（一个操作需要拆分成三个方法）、可复用性低

### (4) 参考实现：ByteTCC

> [https://github.com/liuyangming/ByteTCC/](https://github.com/liuyangming/ByteTCC/)

## 4. 应用消息队列 + 消息表：实现最终一致性（BASE）

### (1) 本地消息表

方法

> 将需要分布式处理的任务，通过消息日志的方式来异步执行
>
> 1. 消息日志：存储在本地文本、数据库、或者消息队列中
>
> 2. 通过业务规则自动或基于事件触发来发起重试
>
> <div align="left"><img src="https://raw.githubusercontent.com/kenfang119/pics/main/sysdesign/sysdesign_distribute_trx_local_msg_table.jpg" width="500" /></div>
>
> 原始论文：["Base: An Acid Alternative"](https://queue.acm.org/detail.cfm?id=1394128)

例子：购买商品

> 1. 将扣款和扣减库存操作写入同一个事务
> 2. 定时任务轮询本地事务表，向商品服务器发送消息
> 3. 商品服务器扣减库存，更新事务表中对应消息的状态
> 4. 商品服务器直接（或通过定时任务）通知扣款服务器
> 5. 扣款服务器进行扣款，并更新事务表中的事务状态
> 6. 备注：(1) 消息可能重复发送、需要进行重复检查 (2) 有重试的可能，执行的操作需要保证幂等性

### (2) 参考实现：RocketMQ

事务执行过程如下

> <div align="left"><img src="https://raw.githubusercontent.com/kenfang119/pics/main/sysdesign/sysdesign_roketmq_trx.jpg" width="600" /></div>

正常情况：

> * 阶段一：生产者发送Prepared Message到消息队列，并得到一个功能类似句柄的`消息地址`
>
> * 阶段二：生产者执行本地事务
>
> * 阶段三：生产者通过`消息地址`来修改消息的状态，使接受者能够收到这个消息

异常情况：

> * 生产者本地事务失败：阶段三不会发生，因此消费者无法接收到消息
> * 消费者接收消息超时：消息集群会自动进行重试，因此Consumer在处理消息时需要保证幂等性

同样以商品购买为例，事务执行过程如下

> <div align="left"><img src="https://raw.githubusercontent.com/kenfang119/pics/main/upload/sysdesign_disttrx_base_seqdiagram.png" width="500" /></div>
>
> 1. 订单系统向消息队列发送预备扣减库存的消息，消息队列保存消息并返回ACK（不会立即发往库存系统），而订单系统则可以得到消息队列的`回调接口`
> 2. 订单系统（收到消息队列的ACK之后）执行本地事务（下单操作）
>     * 如果本地事务执行成功：通过回调接口通知消息队列，将消息发往库存系统，执行库存扣减操作
>     * 如果本地事务执行失败：通过回调接口通知消息队列进行回滚
> 3. 库存系统收到库存扣减的消息后，执行本地事务
>     * 如果库存系统扣减失败，会进行重试
>     * 对应于超过重试次数分布式事务，会由启动定时任务来执行补偿操作（回滚）

## 5. SAGA

### (1) 原理

> 将长事务拆分为多个本地短事务，由Sega事务协调器处理。
>
> 每个短事务都有两种操作：T（事务操作），C（补偿操作：失败回滚时使用）
>
> * 正常情况：按正向顺序执行事务操作 T<sub>1</sub>，T<sub>2</sub>，……，T<sub>n</sub>
> * 异常情况：按反向顺序执行补偿操作进行回滚：T<sub>1</sub>，T<sub>2</sub>，……，T<sub>j</sub>，C<sub>j</sub>，C<sub>2</sub>，……，C<sub>1</sub>
>
> 原版的Sega模式中，没有进行事务隔离，因此会被其他事务影响。解决如下：
>
> * 华为对Sega的实现中，在业务层加入了Session以及锁机制，来保证串行化操作资源
> * 也可以在业务逻辑的设计层面，引入类似资金冻结这样的步骤，来隔离这部分接下来要用的资源

### (2) 参考实现：servicecomb

> 华为的servicecomb

## 6. Seata（AT模式）

> 从两阶段提交演变而来的分布式事务解决方案，提供了`AT`，`TCC`，`SAGA`，`XA`等事务模式，下面是`AT`模式的介绍

### (1) AT模式事务执行过程

角色：

> `TM`（Transaction Manager）：事务管理者，业务代码中用来开启/提交/回滚`全局事务`（在调用服务的方法中用注解开启事务）
>
> `TC`（Transaction Coordinator）：全局事务提交者、用来协调全局事务与分支事务的状态，驱动分支事务提交或回滚
>
> `RM`（Resource Manager）：资源管理者，管理分支事务（Branch Transaction），与TC进行协调、注册分支事务并汇报事务状态，驱动分支事务的提交或回滚

回滚日志记录表：`UNDO_LOG`表

> 每个应用分布式事务的业务库中，都需要创建这张表，用来将业务数据在更新前后祖泽成回滚日志

事务执行过程

> 阶段1：执行各分支事务并记录Redo和Undo日志
>
> * RM获取本地锁，执行分支事务，包括：
>     * 执行分支事务内的操作
>     * 将分支事务之前前、执行后的数据镜像，阻止成Redo和Undo日志，写入UNDO_LOG表中
>     * 向TC注册，为要修改的记录申请全局锁（一段时间拿不到会触发事务本地回滚）
> * RM释放本地锁
>
> 阶段2：根据各分支事务的决议做提交或回滚
>
> * 如果决议是全局提交，TC向各个RM发送提交请求，而RM执行如下操作
>     * RM将请求放入异步任务队列、并立刻返回Success Response给TC
>     * RM的异步任务，批量将队列请求中Branch ID对应的UNDO LOG删除
>     * 释放全局锁
> * 如果决议是全局回滚：TC向各个RM发送回滚命令
>     * RM重新获得本地锁（如果拿不到则继续重试）
>     * RM根据UNDO LOG反向生成回滚SQL并执行，完成分支事务的回滚
>     * RM释放本地锁
>     * 释放全局锁

### (2) 详细信息参考

> [http://seata.io/zh-cn/docs/overview/what-is-seata.html](http://seata.io/zh-cn/docs/overview/what-is-seata.html)

## 附录：CAP和BASE

### (1) CAP

> `P（分区容错性）`：当出现网络分区后（例如某个节点的网络出现故障），整个分布式系统仍然能够继续工作
>
> `A（可用性）`：非故障节点在合理时间内返回合理的响应
>
> * 合理时间：请求不会被无限阻塞，在合理时间内返回
> * 合理响应：返回正确的计算结果
>
> `C（一致性）`：读操作能返回最新的写操作
>
> * 强一致性：某个节点更新了数据，其他节点都能读取到这个最新的数据

### (2) BASE

> `BA：Basically Available，基本可用`：分布式系统出现故障时、容许损失部分功能的可用性，但核心功能仍然可用
>
> `S：Soft State，软状态`：容许系统中存在中间状态（短暂的不一致）并且不会影响可用性
>
> `E：Eventually Consistent，最终一致性`：经过一段时间后，所有节点的数据都将达到一致